-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

local class = require('class')

local log = haka.log_section("grammar")

local module = class.class("CComp")

local suffix = "_grammar"

function module.method:__init(name)
	self._name = name..suffix
	self._cfile = self._name..".c"
	self._sofile = self._name..".so"
	self._parser = nil -- Current parser
	self._parsers = {}

	-- Open and init c file
	self._fd = assert(io.open(self._cfile, "w"))

	-- Create c grammar
	self:write[[
/** File automatically generated by Haka. DO NOT EDIT */
#include <assert.h>

#include <haka/lua/lua.h>
#include <haka/lua/state.h>

#define PARSE_ENTITIES 1
#define PARSE_CTX 2
#define PARSE_INPUT 3
]]
end

function module.method:create_parser(name, dgraph)
	self:_start_parser(name)

	local iter = dgraph

	while iter do
		iter = iter:ccomp(self)
	end

	self:_end_parser()
end

function module.method:_start_parser(name)
	assert(not self._parser_started, "parser already started")
	self._parser = { name = name, fname = "parse_"..name, store = {} }
	self._parsers[#self._parsers + 1] = self._parser
	self:write([[

int parse_%s(lua_State *L)
{
	/**
	 * arg1 = _entities table
	 * arg2 = parse context
	 * arg3 = input
	 */
	int top, error_formater;
	top = lua_gettop(L);

	assert(top == 3);
	assert(lua_istable(L, PARSE_ENTITIES));

	lua_pushcfunction(L, lua_state_error_formater);
	error_formater = lua_gettop(L);
]], name)
end

function module.method:_end_parser()
	assert(self._parser, "parser not started")
	self._parser = nil
	self:write[[

	lua_getfield(L, PARSE_CTX, "_results"); /* get ctx._results */
	lua_rawgeti(L, -1, 1);                 /* result stand first in table */
	lua_remove(L, -2);                     /* remove ctx._results */

	return 1;
}
]]
end

function module.method:write_entity_header(entity)
	local rule = entity.rule or "<unknown>"
	local field = entity.id
	if entity.name then
		field = string.format("'%s'", entity.name)
	end
	local type = class.classof(entity).name

	self:write([[

	/* in rule '%s' field %s <%s> */
]], rule, field, type)
end

function module.method:apply_entity(entity)
	assert(self._parser, "cannot add entity apply without started parser")
	assert(entity)

	local id = #self._parser.store + 1

	self._parser.store[id] = entity
	self:write_entity_header(entity)
	self:write([[
	lua_rawgeti(L, PARSE_ENTITIES, %d);       /* get entity */
	lua_getfield(L, -1, "_trace");            /* entity:_trace */
	lua_pushvalue(L, -2);                     /* pass entity as self */
	lua_getfield(L, PARSE_CTX, "iter");       /* parse_ctx.iter */

	if (lua_pcall(L, 2, 0, error_formater)) { /* entity:_trace(parse_ctx.iter) */
		lua_state_print_error(L, "_parse");
		return 0;
	}

	lua_getfield(L, -1, "_apply");            /* entity:_apply */
	lua_pushvalue(L, -2);                     /* pass entity as self */
	lua_pushvalue(L, PARSE_CTX);              /* parse_ctx */

	if (lua_pcall(L, 2, 0, error_formater)) { /* entity:_apply(parse_ctx) */
		lua_state_print_error(L, "_parse");
		return 0;
	}

	lua_remove(L, -1);                        /* remove entity from stack */

]], id)
end

function module.method:compile()
	assert(not self._parser, "unfinished parser ", self._parsers[#self._parsers].name)

	-- Luaopen
	self:write([[

int luaopen_%s(lua_State *L)
{
	lua_newtable(L);
]], self._name)

	-- Expose all parser
	for _, value in pairs(self._parsers) do
		self:write([[
	lua_pushcfunction(L, parse_%s);
	lua_setfield(L, -2, "parse_%s");
]], value.name, value.name)
	end

	self:write[[
	return 1;
}
]]
	self._fd:close()

	-- Compile c grammar
	local compile_command = "gcc -shared -g -Wall -o "..self._sofile.." -fPIC "..self._cfile
	log.info("compiling grammar '%s': %s", self._name, compile_command)
	os.execute(compile_command)

	return self._name
end

function module.method:write(string, ...)
	assert(self._fd, "uninitialized template")
	self._fd:write(string.format(string, ...))
end

return module
