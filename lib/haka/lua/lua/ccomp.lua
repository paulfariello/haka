-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

local class = require('class')

local log = haka.log_section("grammar")

local module = class.class("CComp")

local suffix = "_grammar"

function module.method:__init(name)
	self._name = name..suffix
	self._cfile = self._name..".c"
	self._sofile = self._name..".so"
	self._parser = nil -- Current parser
	self._parsers = {}

	-- Open and init c file
	self._fd = assert(io.open(self._cfile, "w"))

	-- Create c grammar
	self:write[[
/** File automatically generated by Haka. DO NOT EDIT */
#include <assert.h>

#include <haka/lua/lua.h>
#include <haka/lua/state.h>

#define PARSE_STORE 1
#define PARSE_CTX 2
#define PARSE_INPUT 3
]]
end

local function traverse(ccomp, edge)
	if ccomp._parser.written_edges[edge] then
		ccomp:jumpto(edge)
		return
	end

	local nexts = edge:ccomp(ccomp)
	if #nexts == 0 then
		-- Reach one end of the graph
		ccomp:jumptoend()
	end
	for _, iter in pairs(nexts) do
		traverse(ccomp, iter)
	end
end

function module.method:create_parser(name, dgraph)
	self:_start_parser(name)

	traverse(self, dgraph)

	self:_end_parser()
end

function module.method:_start_parser(name)
	assert(not self._parser, "parser already started")
	self._parser = {
		name = name,
		fname = "parse_"..name,
		store = {}, -- Store some lua object to access it from c
		edges = {}, -- Store all encountered edges
		edges_count = 0, -- Count of encountered edges
		written_edges = {}, -- Store written edges
	}
	self._parsers[#self._parsers + 1] = self._parser
	self:write([[

int parse_%s(lua_State *L)
{
	/**
	 * arg1 = store table
	 * arg2 = parse context
	 * arg3 = input
	 */
	int top, error_formater;
	top = lua_gettop(L);

	assert(top == 3);
	assert(lua_istable(L, PARSE_STORE));

	lua_pushcfunction(L, lua_state_error_formater);
	error_formater = lua_gettop(L);
]], name)
end

function module.method:_end_parser()
	assert(self._parser, "parser not started")
	self:write([[

%s_end:
	lua_getfield(L, PARSE_CTX, "_results"); /* get ctx._results */
	lua_rawgeti(L, -1, 1);                  /* result stand first in table */
	lua_remove(L, -2);                      /* remove ctx._results */

	return 1;
}
]], self._parser.name)
	self._parser = nil
end

function module.method:store(obj)
	assert(self._parser, "parser not started")
	assert(obj, "cannot store nil")
	local id = #self._parser.store + 1

	self._parser.store[id] = obj
	return id
end

function module.method:push_stored(id, name)
	name = name or "anonymous stored object"
	self:write([[
		lua_rawgeti(L, PARSE_STORE, %d);           /* get %s */
]], id, name)
end

function module.method:register(edge)
	self._parser.edges_count = self._parser.edges_count + 1
	self._parser.edges[edge] = self._parser.edges_count
	return self._parser.edges_count
end

function module.method:start_edge(edge)
	assert(self._parser, "parser not started")
	local rule = edge.rule or "<unknown>"
	local field = edge.id
	if edge.name then
		field = string.format("'%s'", edge.name)
	end
	local type = class.classof(edge).name
	-- Register edge if it is not
	local id = self._parser.edges[edge]
	if not id then
		id = self:register(edge)
	end

	-- Mark as written
	self._parser.written_edges[edge] = true

	self:write([[

%s_%d:
	{
		/* in rule '%s' field %s <%s> */
]], self._parser.name, id, rule, field, type)
end

function module.method:finish_edge()
	assert(self._parser, "parser not started")
	self:write[[
	}
]]
end

function module.method:pcall(nargs, nresults, fname)
	assert(self._parser, "parser not started")
	fname = fname or "anonymous function"
	self:write([[
		if (lua_pcall(L, %d, %d, error_formater)) { /* %s */
			lua_state_print_error(L, "_parse");
			return 0;
		}
]], nargs, nresults, fname)
end

function module.method:jumpto(edge)
	assert(self._parser, "parser not started")
	assert(self._parser.edges[edge], "unknown edge to jump to")
	self:write([[
	goto %s_%d;
]], self._parser.name, self._parser.edges[edge])
end

function module.method:jumptoend(edge)
	assert(self._parser, "parser not started")
	self:write([[
	goto %s_end;
]], self._parser.name)
end

function module.method:apply_edge(edge)
	assert(self._parser, "cannot apply edge without started parser")
	assert(edge)

	self:start_edge(edge)

	self:push_stored(self:store(edge), "edge")
	self:write[[
		lua_getfield(L, -1, "_trace");            /* edge:_trace */
		lua_pushvalue(L, -2);                     /* pass edge as self */
		lua_getfield(L, PARSE_CTX, "iter");       /* parse_ctx.iter */
]]
	self:pcall(2, 0, "edge:_trace(parse_ctx.iter)")

	self:write[[
		lua_getfield(L, -1, "_apply");            /* edge:_apply */
		lua_pushvalue(L, -2);                     /* pass edge as self */
		lua_pushvalue(L, PARSE_CTX);              /* parse_ctx */
]]

	self:pcall(2, 0, "edge:_apply(parse_ctx)")

	self:write[[
		lua_remove(L, -1);                        /* remove edge from stack */

]]
	self:finish_edge()
end

function module.method:compile()
	assert(not self._parser, "unfinished parser ", self._parsers[#self._parsers].name)

	-- Luaopen
	self:write([[

int luaopen_%s(lua_State *L)
{
	lua_newtable(L);
]], self._name)

	-- Expose all parser
	for _, value in pairs(self._parsers) do
		self:write([[
	lua_pushcfunction(L, parse_%s);
	lua_setfield(L, -2, "parse_%s");
]], value.name, value.name)
	end

	self:write[[
	return 1;
}
]]
	self._fd:close()

	-- Compile c grammar
	local compile_command = "gcc -shared -g -Wall -Wno-unused-label -Werror -o "..self._sofile.." -fPIC "..self._cfile
	log.info("compiling grammar '%s': %s", self._name, compile_command)
	os.execute(compile_command)

	return self._name
end

function module.method:write(string, ...)
	assert(self._fd, "uninitialized template")
	self._fd:write(string.format(string, ...))
end

return module
